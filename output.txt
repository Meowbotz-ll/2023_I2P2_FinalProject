File: .\bullet.cpp 
-------------- 
#include "bullet.h"
#include "log.h"


const float Bullet::SIZE = 10.0f;

Bullet::Bullet(float x, float y, float dx, float dy)
    : x(x), y(y), dx(dx), dy(dy), hitbox(x, y, Bullet::SIZE), alive(true) {
    image = al_load_bitmap("C:/I2P2_final_project/2023_I2P2_FinalProject/bullet.jpg");
    if (!image) {
        Log::Error("Failed to load bullet image");
    }
}

    
Bullet::~Bullet() {
    if (image) {
        al_destroy_bitmap(image);
    }
}

void Bullet::update() {
    if (alive) {
        x += dx;
        y += dy;
        hitbox.x = x;
        hitbox.y = y;
    }
}

void Bullet::draw() const {
    if (alive && image) {
        al_draw_bitmap(image, x, y, 0);
    }
}

bool Bullet::isAlive() const {
    return alive;
}

void Bullet::hit() {
    alive = false;
}

float Bullet::getX() const {
    return x;
}

float Bullet::getY() const {
    return y;
}
============== 
File: .\circle.cpp 
-------------- 
#include "Circle.h"

// 判斷兩個圓是否重疊的函數
bool Circle::isOverlap(const Circle *circle_1, const Circle *circle_2)
{
    // 計算兩圓半徑和
    int length = circle_1->r + circle_2->r;

    // 計算兩圓中心的距離的平方
    int distance_square = (circle_1->x - circle_2->x) * (circle_1->x - circle_2->x)
                            + (circle_1->y - circle_2->y) * (circle_1->y - circle_2->y);

    // 判斷是否重疊
    if(length * length >= distance_square)
        return true;

    return false;
}
============== 
File: .\enemy.cpp 
-------------- 
#include "enemy.h"
#include "global.h"
#include "bullet.h"
#include "log.h"
#include <cstdlib>
#include <ctime>

Enemy::Enemy()
    : x(0), y(0), speed(2.0), alive(false), color(al_map_rgb(255, 255, 0)) ,hitbox(x, y, ENEMY_RADIUS){ // Yellow color
    std::srand(std::time(0)); // Seed for random number generation.
    image = al_load_bitmap("C:/I2P2_final_project/2023_I2P2_FinalProject/enemy.jpg");
    if (!image) {
        Log::Error("Failed to load enemy image");
    }
    respawn();
}

Enemy::~Enemy() {
    if (image) {
        al_destroy_bitmap(image);
    }
}

void Enemy::initialize() {
    respawn();
}

void Enemy::update() {
    if (alive) {
        x += speed;

        // Check if the enemy is out of the screen.
        if (x > al_get_display_width(al_get_current_display())) {
            respawn();
        }
        hitbox.x = x;
        hitbox.y = y;
    }
}

void Enemy::draw() const {
    if (alive && image) {
        al_draw_bitmap(image, x, y, 0);
    }
}

bool Enemy::isAlive() const {
    return alive;
}

void Enemy::hit() {
        alive = false;
}

float Enemy::getX() const {
    return x;
}

float Enemy::getY() const {
    return y;
}

void Enemy::respawn() {
    x = 0 - rand() % 400; // Randomize initial x position off the screen.
    y = rand() % (al_get_display_height(al_get_current_display()) - 20);
    alive = true;
    hitbox.x = x;
    hitbox.y = y;
}
============== 
File: .\gameWindow.cpp 
-------------- 
#include <algorithm>
#include "gameWindow.h"
#include "allegro_setup.h"
#include "log.h"  // Include your log class

GameWindow::GameWindow() : doexit(false) {
    Log::Info("GameWindow Created");
    init();
}

GameWindow::~GameWindow() {
    Log::Info("GameWindow Deleted");
    al_destroy_display(display);
    al_destroy_event_queue(event_queue);
}

void GameWindow::init() {
    Log::Info("Init Started:");

    // Initialize Allegro subsystems
    if (!al_init()) {
        Log::Error("Failed to initialize Allegro");
        return;
    }
    if (!al_install_keyboard()) {
        Log::Error("Failed to initialize keyboard");
        return;
    }
    if (!al_init_image_addon()) {
        Log::Error("Failed to initialize image addon");
        return;
    }
    if (!al_init_primitives_addon()) {
        Log::Error("Failed to initialize primitives addon");
        return;
    }
    if (!al_install_mouse()) {
        Log::Error("Failed to initialize mouse");
        return;
    }
    // Initialize other necessary Allegro add-ons here

    // Create display
    display = al_create_display(800, 600);
    if (!display) {
        Log::Error("Display failed to be created");
        return;
    } else {
        Log::Info("Display created");
    }

    // Create timer
    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 60.0); // 60 FPS
    if (!timer) {
        Log::Error("Timer failed to be created");
        return;
    } else {
        Log::Info("Timer created");
    }

    // Create event queue
    event_queue = al_create_event_queue();
    if (!event_queue) {
        Log::Error("Event queue failed to be created");
        return;
    } else {
        Log::Info("Event queue created");
    }

    // Register event sources
    al_register_event_source(event_queue, al_get_display_event_source(display));
    al_register_event_source(event_queue, al_get_keyboard_event_source());
    al_register_event_source(event_queue, al_get_timer_event_source(timer));
    al_register_event_source(event_queue, al_get_mouse_event_source());
    al_start_timer(timer);

    player.init(400, 500);

    // Initialize enemies
    for (int i = 0; i < 5; ++i) {
        Enemy enemy;
        enemy.initialize();
        enemies.push_back(enemy);
    }

    Log::Info("GameWindow initialization complete");
}


void GameWindow::run() {
    Log::Info("Game Started!");
   
    while (!doexit) {
        ALLEGRO_EVENT ev;
        al_wait_for_event(event_queue, &ev);

        switch (ev.type) {
            case ALLEGRO_EVENT_TIMER:
                player.update();

                 // Check for collisions between bullets and enemies
                // 在 GameWindow::run 方法中
                for (auto& bullet : bullets) {
                    for (auto& enemy : enemies) {
                        if (bullet.isAlive() && enemy.isAlive() && checkCollision(bullet, enemy)) {
                            Log::Info("Collision Detected");
                            bullet.hit();
                            enemy.hit();
                        }
                    }
                }

                // Update living enemies
                                for (auto& enemy : enemies) {
                                    enemy.update();
                                }
                
                // 移除不活躍的子彈和敵人
                erase();
                
                // Add any other updates here, e.g., for game world, enemies, etc.
                break;

            case ALLEGRO_EVENT_DISPLAY_CLOSE:
                doexit = true;
                break;

            case ALLEGRO_EVENT_KEY_DOWN:
                key_state[ev.keyboard.keycode] = true;
                break;

            case ALLEGRO_EVENT_KEY_UP:
                key_state[ev.keyboard.keycode] = false;
                if (ev.keyboard.keycode == ALLEGRO_KEY_ESCAPE) {
                    doexit = true;
                }
                break;

            case ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
                if (ev.mouse.button & 1) { // Left mouse button
                    Log::Info("Left Mouse Button Clicked");
                    player.shoot(ev.mouse.x, ev.mouse.y);
                }
                break;

            // Add additional cases here for other types of events
        }

        draw();
    }
}

void GameWindow::erase(){
    // 移除不活躍的子彈
    bullets.erase(std::remove_if(bullets.begin(), bullets.end(),
                                 [](const Bullet& bullet) { return !bullet.isAlive(); }),
                  bullets.end());

    // 移除不活躍的敵人
    enemies.erase(std::remove_if(enemies.begin(), enemies.end(),
                                 [](const Enemy& enemy) { return !enemy.isAlive(); }),
                  enemies.end());
}


void GameWindow::draw() const {
    al_clear_to_color(al_map_rgb(0, 0, 0));
    player.draw();
    for (const auto& enemy : enemies) {
        enemy.draw();
    }
    for (const auto& bullet : bullets) {
        bullet.draw();
    }
    al_flip_display();
}



bool GameWindow::checkCollision(const Bullet& bullet, const Enemy& enemy) const {
    Log::Info("Attack!");
    // 在 GameWindow::checkCollision 方法中
    return Circle::isOverlap(&(bullet.hitbox), &(enemy.getHitbox()));

}


============== 
File: .\global.cpp 
-------------- 
#include "global.h"

bool key_state[ALLEGRO_KEY_MAX] = { false };
============== 
File: .\level.cpp 
-------------- 
#include "level.h"

Level::Level() {
    // Constructor implementation
}

void Level::loadLevel(const char* filename) {
    // Load level data from file
}

void Level::update() {
    // Update level objects
}

void Level::render() {
    // Render level
}
============== 
File: .\log.cpp 
-------------- 
#include "log.h"

void Log::Info(const std::string& message) {
    std::cout << "INFO: " << message << std::endl;
}

void Log::Error(const std::string& message) {
    std::cerr << "ERROR: " << message << std::endl;
}
============== 
File: .\main.cpp 
-------------- 
#include "gameWindow.h"
#include "allegro_setup.h"
#include <iostream>
using namespace std;

int main() {
    GameWindow window;
    window.run();

    return 0;
}
============== 
File: .\player.cpp 
-------------- 
#include "player.h"
#include "global.h"
#include "bullet.h"
#include "log.h"
#include <vector>
#include <cmath>

std::vector<Bullet> bullets;
const float GRAVITY = 0.5;
const float JUMP_STRENGTH = -10.0;
const int PLAYER_SIZE = 32;

Player::Player() : x(0), y(0), dy(0), onGround(true), facingRight(true), bulletSpeed(15.0f) {
    image = al_load_bitmap("C:/I2P2_final_project/2023_I2P2_FinalProject/player.png");
    if (!image) {
        Log::Error("Failed to load player image");
    }
}

Player::~Player() {
    if (image) {
        al_destroy_bitmap(image);
    }
    // 注意：如果 Player 類中也有子彈的列表，也需要釋放這些子彈的資源。
}

void Player::init(float x, float y) {
    this->x = x;
    this->y = y;
}

void Player::update() {
    if (!onGround) {
        dy += GRAVITY;
        y += dy;
    }

    if (y >= 600 - 100 - PLAYER_SIZE) {
        y = 600 - 100 - PLAYER_SIZE;
        dy = 0;
        onGround = true;
    }

    if (key_state[ALLEGRO_KEY_A]) {
        x -= 4.0;
        facingRight = false;
    }
    if (key_state[ALLEGRO_KEY_D]) {
        x += 4.0;
        facingRight = true;
    }

    if (key_state[ALLEGRO_KEY_SPACE] && onGround) {
        dy = JUMP_STRENGTH; // 設定向上的速度
        onGround = false;   // 標記玩家不再在地面上
    }

    // Update bullets
    for (auto& bullet : bullets) {
        bullet.update();
    }
}

void Player::draw() const {
    if (image) {
        al_draw_bitmap(image, x, y, 0);
    }
    // 繪製子彈
    for (const auto& bullet : bullets) {
        bullet.draw();
    }
}

void Player::shoot(float target_x, float target_y) {
    float dx = target_x - x;
    float dy = target_y - y;
    float length = std::sqrt(dx * dx + dy * dy);
    dx /= length; // Normalize
    dy /= length;
    
    // Use bulletSpeed to determine the velocity of the bullet
    dx *= bulletSpeed;
    dy *= bulletSpeed;

    bullets.push_back(Bullet(x, y, dx, dy));
}

============== 
