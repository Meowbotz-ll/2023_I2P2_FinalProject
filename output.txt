File: .\bullet.cpp 
-------------- 
#include "bullet.h"

int Bullet::DEFAULT_DAMAGE = 1; // 初始化静态成员变量

Bullet::Bullet(float x, float y, float dx, float dy) : x(x), y(y), dx(dx), dy(dy), alive(true), damage(Bullet::DEFAULT_DAMAGE) {}

void Bullet::update() {
    x += dx;
    y += dy;
    // Added: Check if the bullet is out of screen bounds
    if (x < 0 || x > 800 || y < 0 || y > 600) {
        alive = false;
    }
}

void Bullet::draw() {
    if(!alive) return;
    al_draw_filled_rectangle(x, y, x + SIZE, y + SIZE, al_map_rgb(255, 255, 255));
}

void Bullet::setAlive(bool status) {
    alive = status;
}
============== 
File: .\enemy.cpp 
-------------- 
#include "Enemy.h"

int Enemy::DEFAULT_HP = 5;  // 初始化静态成员变量

Enemy::Enemy(float x, float y) 
    : x(x), y(y), hp(Enemy::DEFAULT_HP), color(al_map_rgb(255, 255, 0)), alive(true) {} // 初始化alive为true // Blue color

void Enemy::update() {
    // Update logic for enemy (optional for this example)
}

void Enemy::draw() {
    if(!alive) return;
    al_draw_filled_circle(x, y, RADIUS, color); // Drawing the enemy as a circle
}

void Enemy::hit(int damage) {
    hp -= damage;
    if (hp <= 0) {
        alive = false; // 標記敵人為死亡，不再繪製或更新
    }
}

bool Enemy::isAlive() const {
    return hp > 0;
}============== 
File: .\gameWindow.cpp 
-------------- 
#include "gameWindow.h"
#include "allegro_setup.h"
#include "log.h"  // Include your log class
#include "algorithm"
#include "bullet.h"


#include <iterator>
using namespace std;

GameWindow::GameWindow() : currentState(MENU),doexit(false){
    Log::Info("GameWindow Created");
    init();
    enemies.push_back(Enemy(100, 100));
}

GameWindow::~GameWindow() {
    Log::Info("GameWindow Deleted");
    al_destroy_display(display);
    al_destroy_event_queue(event_queue);
}

void GameWindow::init() {
    Log::Info("Init Started:");

    // Initialize Allegro subsystems
    if (!al_init()) {
        Log::Error("Failed to initialize Allegro");
        return;
    }
    if (!al_install_keyboard()) {
        Log::Error("Failed to initialize keyboard");
        return;
    }
    if (!al_init_image_addon()) {
        Log::Error("Failed to initialize image addon");
        return;
    }
    if (!al_init_primitives_addon()) {
        Log::Error("Failed to initialize primitives addon");
        return;
    }
    if (!al_install_mouse()) {
        Log::Error("Failed to initialize mouse");
        return;
    }
    // Initialize font add-ons
    al_init_font_addon(); // Initialize the font addon
    if (!al_init_ttf_addon()) { // Initialize the TrueType font addon
        Log::Error("Failed to initialize TTF font addon");
        return;
    }
// Initialize the font for the menu
    Log::Info("Loading font...");
    font = al_load_font("fonts/ARCADE.TTF", 36, 0);
    if (!font) {
        Log::Error("Failed to load font at fonts/ARCADE.TTF");
    }
    menu.init(font);
// Initialize audio subsystem
    if (!al_install_audio()) {
        Log::Error("Failed to initialize audio");
        return;
    }
    if (!al_init_acodec_addon()) {
        Log::Error("Failed to initialize audio codec addon");
        return;
    }
    if (!al_reserve_samples(16)) {  // Reserve enough sample instances for your game
        Log::Error("Failed to reserve audio samples");
        return;
    }
    // Init background Music
    menuMusic = al_load_sample("audio/Electroman-Adventures.ogg");
    gameMusic = al_load_sample("audio/Electroman-Adventures.ogg");

if (!menuMusic || !gameMusic) {
    Log::Error("Failed to load music files");
    return;
}

    // Create display
    display = al_create_display(800, 600);
    if (!display) {
        Log::Error("Display failed to be created");
        return;
    } else {
        Log::Info("Display created");
    }

    // Create timer
    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 60.0); // 60 FPS
    if (!timer) {
        Log::Error("Timer failed to be created");
        return;
    } else {
        Log::Info("Timer created");
    }

    // Create event queue
    event_queue = al_create_event_queue();
    if (!event_queue) {
        Log::Error("Event queue failed to be created");
        return;
    } else {
        Log::Info("Event queue created");
    }

    // Register event sources
    al_register_event_source(event_queue, al_get_display_event_source(display));
    al_register_event_source(event_queue, al_get_keyboard_event_source());
    al_register_event_source(event_queue, al_get_timer_event_source(timer));
    al_register_event_source(event_queue, al_get_mouse_event_source());
    al_start_timer(timer);

    player.init(400, 500);

    Log::Info("GameWindow initialization complete");
}


void GameWindow::run() {
    Log::Info("Game Started!");

    while (!doexit) {
        ALLEGRO_EVENT ev;
        al_wait_for_event(event_queue, &ev);
        switch (currentState) {
            case MENU:
            //Log::Info("In Menu State");
                if (ev.type == ALLEGRO_EVENT_KEY_UP) {
                    if (ev.keyboard.keycode == ALLEGRO_KEY_ENTER) {
                        Log::Info("Enter Key Pressed - Switching to Game State"); // Debug message for pressing Enter
                        al_stop_samples(); // Stop any currently playing music
                        currentState = GAME;
                        menu.gameStart = true; // Update the flag in menu
                    }
                }
                menu.update();
                break;

            case GAME:
            //Log::Info("In Menu State");
        switch (ev.type) {
            case ALLEGRO_EVENT_TIMER:
            
                player.update();
                for (auto& enemy : enemies) {
                    enemy.update();
                }
                
                // Add any other updates here, e.g., for game world, enemies, etc.
                break;

            case ALLEGRO_EVENT_DISPLAY_CLOSE:
                doexit = true;
                break;

            case ALLEGRO_EVENT_KEY_DOWN:
                key_state[ev.keyboard.keycode] = true;
                break;

            case ALLEGRO_EVENT_KEY_UP:
                key_state[ev.keyboard.keycode] = false;
                if (ev.keyboard.keycode == ALLEGRO_KEY_ESCAPE) {
                    Log::Info("Escape Key Pressed - Switching to Menu State"); // Debug message for pressing Escape
                    al_stop_samples(); // Stop any currently playing music
                    currentState = MENU;
                }
                break;

            case ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
                if (ev.mouse.button & 1) { // Left mouse button
                    Log::Info("Left Mouse Button Clicked");
                    player.shoot(ev.mouse.x, ev.mouse.y);
                }
                break;

            // Add additional cases here for other types of events
        }
        // 处理子弹和敌人的碰撞
        /*for (auto& bullet : player.getBullets()) {
            for (auto& enemy : enemies) {
                if (checkCollision(bullet, enemy) && enemy.isAlive()) {
                    enemy.hit(1);
                }
            }
        }*/

        /*for (auto& bullet : player.getBullets()) {
            for (auto& enemy : enemies) {
                if (checkCollision(bullet, enemy) && enemy.isAlive()) {
                    enemy.hit(bullet.damage);
                    player.markBulletDead(1);
                    break;
                }
            }
        }*/
        for (auto& bullet : player.getBullets()) {
            for (auto& enemy : enemies) {
                if (checkCollision(bullet, enemy) && enemy.isAlive()) {
                    enemy.hit(Bullet::DEFAULT_DAMAGE);
                    bullet.setAlive(false); // 碰撞後標記子彈為不活動
                    break; // 避免同一子彈多次碰撞檢測
                }
            }
        }


    

        // 移除不活躍的子彈和敵人
        /*bullets.erase(std::remove_if(bullets.begin(), bullets.end(), 
                    [](const Bullet& bullet) { return !bullet.isAlive(); }), bullets.end());*/
        enemies.erase(std::remove_if(enemies.begin(), enemies.end(), 
                    [](const Enemy& enemy) { return !enemy.isAlive(); }), enemies.end());

        break;

        }

        draw();
    }
}


void GameWindow::draw() {
    al_clear_to_color(al_map_rgb(0, 0, 0));

    switch (currentState) {
        case MENU:
            al_play_sample(menuMusic, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP, NULL);
            menu.draw();
            break;

        case GAME:
            al_play_sample(gameMusic, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP, NULL);
            player.draw();
    for (auto& enemy : enemies) {
        enemy.draw();
    }
            // Draw other game elements
            break;
    }

    al_flip_display();
}
bool GameWindow::checkCollision(const Bullet &bullet, const Enemy &enemy) {
    // Simple circle-rectangle collision detection
    float distX = std::abs(bullet.x - enemy.x);
    float distY = std::abs(bullet.y - enemy.y);

    if (distX > (Bullet::SIZE / 2 + Enemy::RADIUS)) { return false; }
    if (distY > (Bullet::SIZE / 2 + Enemy::RADIUS)) { return false; }

    if (distX <= (Bullet::SIZE / 2)) { return true; } 
    if (distY <= (Bullet::SIZE / 2)) { return true; }

    // Corner collision
    float dx = distX - Bullet::SIZE / 2;
    float dy = distY - Bullet::SIZE / 2;
    return (dx * dx + dy * dy <= (Enemy::RADIUS * Enemy::RADIUS));
}

============== 
File: .\global.cpp 
-------------- 
#include "global.h"

bool key_state[ALLEGRO_KEY_MAX] = { false };
============== 
File: .\level.cpp 
-------------- 
#include "level.h"

Level::Level() {
    // Constructor implementation
}

void Level::loadLevel(const char* filename) {
    // Load level data from file
}

void Level::update() {
    // Update level objects
}

void Level::render() {
    // Render level
}
============== 
File: .\log.cpp 
-------------- 
#include "log.h"

void Log::Info(const std::string& message) {
    std::cout << "INFO: " << message << std::endl;
}

void Log::Error(const std::string& message) {
    std::cerr << "ERROR: " << message << std::endl;
}
============== 
File: .\main.cpp 
-------------- 
#include "gameWindow.h"
#include "allegro_setup.h"
#include <iostream>
using namespace std;

int main() {
    GameWindow window;
    window.run();

    return 0;
}
============== 
File: .\menu.cpp 
-------------- 
// menu.cpp
#include "menu.h"
#include "log.h"
Menu::Menu() : gameStart(false), font(nullptr) {}

Menu::~Menu() {
    // Font is managed by GameWindow, so no need to destroy it here
}

void Menu::init(ALLEGRO_FONT* font) {
    this->font = font;
}

void Menu::update() {
    // Update logic for the menu (e.g., button highlights)
}

void Menu::draw() {
    if (!font) {
        //Log::Error("Font not loaded");
        return;
    }
    
    al_draw_text(font, al_map_rgb(255, 255, 255), 400, 300, ALLEGRO_ALIGN_CENTER, "Press Enter to Start");
}

bool Menu::startGame() const {
    return gameStart;
}

// Implement any additional methods you need for the menu============== 
File: .\player.cpp 
-------------- 
#include "player.h"
#include "global.h"
#include "bullet.h"
#include <vector>
#include <cmath>
#include <algorithm>


const float GRAVITY = 0.5;
const float JUMP_STRENGTH = -10.0;
const int PLAYER_SIZE = 32;

Player::Player() : x(0), y(0), dy(0), onGround(true), facingRight(true), bulletSpeed(15.0f),dashing(false),lastDashTime(0.0){
}

void Player::init(float x, float y) {
    this->x = x;
    this->y = y;
}

void Player::update() {
    if (!onGround) {
        dy += GRAVITY;
        y += dy;
    }

    if (y >= 600 - 100 - PLAYER_SIZE) {
        y = 600 - 100 - PLAYER_SIZE;
        dy = 0;
        onGround = true;
    }

    if (key_state[ALLEGRO_KEY_A]) {
        x -= 4.0;
        facingRight = false;
    }
    if (key_state[ALLEGRO_KEY_D]) {
        x += 4.0;
        facingRight = true;
    }

    if (key_state[ALLEGRO_KEY_SPACE] && onGround) {
        dy = JUMP_STRENGTH;
        onGround = false;
    }

    if (key_state[ALLEGRO_KEY_F] && !dashing) {
        // Implement dash behavior here
        if(facingRight)
        {
        x += 20.0;
        }
        else if(!facingRight)
        {
        x-=20.0;
        }
        dashing = false;
        lastDashTime = al_get_time(); // Record the time of the dash
    }

        // Check if the cooldown is over and reset the dash flag
    if (al_get_time() - lastDashTime >= DASH_COOLDOWN) {
        dashing = false;
    }

    // Update bullets
    for (auto& bullet : bullets) {
        bullet.update();
    }
    // 移除不活跃的子弹
    /*bullets.erase(std::remove_if(bullets.begin(), bullets.end(), 
                [](const Bullet& bullet) { return !bullet.isAlive(); }), bullets.end());*/
    // 移除不活動的子彈
    /*bullets.erase(std::remove_if(bullets.begin(), bullets.end(), 
                [](const Bullet& bullet) { return !bullet.isAlive(); }), bullets.end());*/

}

void Player::draw() {
    al_draw_filled_rectangle(x, y, x + PLAYER_SIZE, y + PLAYER_SIZE, al_map_rgb(255, 0, 0));
        // Draw each bullet
    for (auto& bullet : bullets) {
        bullet.draw();
    }
}

void Player::shoot(float target_x, float target_y) {
    float dx = target_x - x;
    float dy = target_y - y;
    float length = std::sqrt(dx * dx + dy * dy);
    dx /= length; // Normalize
    dy /= length;
    
    // Use bulletSpeed to determine the velocity of the bullet
    dx *= bulletSpeed;
    dy *= bulletSpeed;

    bullets.push_back(Bullet(x, y, dx, dy));
}

/*void Player::markBulletDead(int index) {
    if (index >= 0 && index < bullets.size()) {
        bullets[index].alive = false;
    }
}*/

void Player::markBulletDead(int index) {
    // 将 index 转换为无符号类型
    auto unsignedIndex = static_cast<std::vector<Bullet>::size_type>(index);

    if (index >= 0 && unsignedIndex < bullets.size()) {
        // 使用公共方法来设置子弹的状态
        bullets[unsignedIndex].setAlive(false);
    }
}




============== 
