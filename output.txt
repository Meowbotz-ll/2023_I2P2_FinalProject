File: .\algif.cpp 
-------------- 
#include "algif.h"
#include <allegro5/allegro_primitives.h>
#include <math.h>

/* Renders the next frame in a GIF animation to the given position.
 * You need to call this in order on the same destination for frames
 * [0..gif->frames_count - 1] to properly render all the frames in the GIF.
 * The current target bitmap should have the same height as the animation,
 * and blending should be set to fully copy RGBA.
 */
void algif_render_frame(ALGIF_ANIMATION *gif, int frame, int xpos, int ypos) {
    int x, y, w, h;
    ALGIF_FRAME *f = &gif->frames[frame];
    ALGIF_PALETTE *pal;
    if (frame == 0) {
        al_draw_filled_rectangle(xpos, ypos, xpos + gif->width,
              ypos + gif->height, al_map_rgba_f(0, 0, 0, 0));
    }
    else {
        ALGIF_FRAME *p = &gif->frames[frame - 1];
        if (p->disposal_method == 2) {
            al_draw_filled_rectangle(xpos + p->xoff, ypos + p->yoff,
                xpos + p->xoff + p->bitmap_8_bit->w,
                ypos + p->yoff + p->bitmap_8_bit->h,
                al_map_rgba_f(0, 0, 0, 0));
        }
        else if (p->disposal_method == 3 && gif->store) {
            al_draw_bitmap_region(gif->store, xpos + p->xoff, ypos + p->yoff,
                p->bitmap_8_bit->w,
                p->bitmap_8_bit->h,
                xpos + p->xoff, ypos + p->yoff, 0);
            al_destroy_bitmap(gif->store);
            gif->store = NULL;
        }
    }
    w = f->bitmap_8_bit->w;
    h = f->bitmap_8_bit->h;
    if (f->disposal_method == 3) {
        if (gif->store)
            al_destroy_bitmap(gif->store);
        gif->store = al_clone_bitmap(al_get_target_bitmap());
    }
    pal = &gif->frames[frame].palette;
    if (pal->colors_count == 0)
        pal = &gif->palette;

    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            int c = f->bitmap_8_bit->data[x + y * f->bitmap_8_bit->w];
            if (c != f->transparent_index) {
                al_draw_pixel(xpos + f->xoff + x, ypos + f->yoff + y,
                    al_map_rgb(pal->colors[c].r, pal->colors[c].g,
                        pal->colors[c].b));
            }
        }
    }
}

ALGIF_ANIMATION *algif_load_animation_f(ALLEGRO_FILE *file) {
    ALGIF_ANIMATION *gif = algif_load_raw(file);

    if (!gif)
        return gif;

    al_init_primitives_addon();

    gif->duration = 0;
    ALLEGRO_STATE s;
    al_store_state(&s, ALLEGRO_STATE_TARGET_BITMAP | ALLEGRO_STATE_BLENDER);
    al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);
    int n = gif->frames_count;
    int i;
    for (i = 0; i < n; i++) {
        ALGIF_FRAME *f = &gif->frames[i];
        f->rendered = al_create_bitmap(gif->width, gif->height);
        al_set_target_bitmap(f->rendered);
        algif_render_frame(gif, i, 0, 0);
        gif->duration += f->duration;
    }

    al_restore_state(&s);
    return gif;
}

ALGIF_ANIMATION *algif_load_animation(char const *filename) {
    ALLEGRO_FILE *file = al_fopen(filename, "rb");
    return algif_load_animation_f(file);
}

ALLEGRO_BITMAP *algif_get_bitmap(ALGIF_ANIMATION *gif, double seconds) {
    if(gif->start_time == 0){
        gif->start_time = seconds;
    }
    seconds -= gif->start_time;
    double gif_duration = gif->duration / 100.0;
    // no loop
    if(gif->loop == -1 && seconds > gif_duration ){
        gif->done = true;
        gif->start_time = 0;
        return nullptr;
    }
    // loop n times
    if(gif->loop > 0 && seconds > gif_duration*gif->loop){
        gif->done = true;
        gif->start_time = 0;
        return nullptr;
    }
    seconds = fmod(seconds, gif_duration);
    int n = gif->frames_count;
    double d = 0;
    int i;
    for (i = 0; i < n; i++) {
        d += gif->frames[i].duration / 100.0;
        if (seconds < d){
            gif->display_index = i;
            return gif->frames[i].rendered;
        }

    }
    return gif->frames[0].rendered;
}

ALLEGRO_BITMAP *algif_get_frame_bitmap(ALGIF_ANIMATION *gif, int i) {
    return gif->frames[i].rendered;
}

double algif_get_frame_duration(ALGIF_ANIMATION *gif, int i) {
    return gif->frames[i].duration / 100.0;
}
============== 
File: .\bitmap.cpp 
-------------- 
#include "algif.h"

ALGIF_BITMAP *algif_create_bitmap(int w, int h) {
    ALGIF_BITMAP *bitmap = (ALGIF_BITMAP *)calloc(1, sizeof *bitmap);
    bitmap->w = w;
    bitmap->h = h;
    bitmap->data = (uint8_t *)calloc(1, w * h);
    return bitmap;
}

void algif_destroy_bitmap(ALGIF_BITMAP *bitmap) {
    free(bitmap->data);
    free(bitmap);
}

void algif_blit(ALGIF_BITMAP *from, ALGIF_BITMAP *to, int xf, int yf, int xt, int yt,
        int w, int h) {

    if (w <= 0 || h <= 0)
        return;

    /* source clipping */
    if (xf < 0) {
        w += xf;
        xt -= xf;
        xf = 0;
    }
    if (yf < 0) {
        h += yf;
        yt -= yf;
        yf = 0;
    }
    int wf = from->w;
    int hf = from->h;
    if (xf + w > wf) {
        w = wf - xf;
    }
    if (yf + h > hf) {
        h = hf - yf;
    }

    /* destination clipping */
    if (xt < 0) {
        w += xt;
        xf -= xt;
        xt = 0;
    }
    if (yt < 0) {
        h += yt;
        yf -= yt;
        yt = 0;
    }
    int wt = to->w;
    int ht = to->h;
    if (xt + w > wt) {
        w = wt - xt;
    }
    if (yt + h > ht) {
        h = ht - yt;
    }

    if (w <= 0 || h <= 0)
        return;

    /* copy row by row */
    uint8_t *pf = from->data + yf * from->w;
    uint8_t *pt = to->data + yt * to->w;
    int i;
    for (i = 0; i < h; i++) {
        memmove(pt + xt, pf + xf, w);
        pf += from->w;
        pt += to->w;
    }
}
============== 
File: .\bullet.cpp 
-------------- 
#include "bullet.h"

Bullet::Bullet(float x, float y, float dx, float dy) : x(x), y(y), dx(dx), dy(dy), alive(true), damage(Bullet::DEFAULT_DAMAGE), hit(false) {}

void Bullet::update() {
    x += dx; // 假設 speed 是成員變量
    y += dy;
    // Added: Check if the bullet is out of screen bounds
    if (x < 0 || x > 800 || y < 0 || y > 600) {
        alive = false;
    }
}

void Bullet::draw() {
    if(!alive) return;
    al_draw_filled_rectangle(x, y, x + size, y + size, al_map_rgb(255, 255, 255));
}

void Bullet::setAlive(bool status) {
    alive = status;
}
============== 
File: .\enemy.cpp 
-------------- 
#include "Enemy.h"
#include "player.h"

#include <cmath>
#include <algorithm>

Enemy::Enemy(float x, float y, float vx, EnemyType type) 
    : x(x), y(y), hp(DEFAULT_HP), vx(vx), color(al_map_rgb(255, 255, 0)), alive(true), offScreen(false), type(type), lastShootTime(0) {}


void Enemy::update() {
    if(type == AIR) x += vx;
    else x += 2*vx;
    
    // 检查是否离开屏幕
    if (x < 0 || x > 800) {  // 假设屏幕宽度为800
        offScreen = true;
    }

    // Update bullets
    for (auto& bullet : bullets) {
        bullet.update();
    }
    
}

void Enemy::draw() {
    if(!alive) return;
    ALLEGRO_COLOR color = (type == AIR) ? al_map_rgb(173, 216, 230) : al_map_rgb(255, 165, 0);
    al_draw_filled_circle(x, y, RADIUS, color); // 根据类型绘制不同颜色的圆
    // Draw each bullet
    for (auto& bullet : bullets) {
        bullet.draw();
    }
}


void Enemy::hit(int damage) {
    hp -= damage;
    if (hp <= 0) {
        alive = false; // 標記敵人為死亡，不再繪製或更新
    }
}

bool Enemy::isAlive() const {
    return hp > 0;
}

void Enemy::shootAtPlayer(const Player& player) {
    //static double lastShootTime = 0;
    double shootInterval = 2.0; // 子弹发射间隔，以秒为单位

    // 当前时间
    double currentTime = al_get_time();

    // 检查是否到达发射间隔
    if (currentTime - lastShootTime > shootInterval) {
        // 重置发射时间
        lastShootTime = currentTime;

        // 发射子弹的逻辑
        if (type == AIR) {
            float dx = player.getX() - x;
            float dy = player.getY() - y;
            float distance = sqrt(dx * dx + dy * dy);
            dx /= distance;
            dy /= distance;

            // 设置子弹速度
            float bulletSpeed = 2.0f; // 减慢子弹速度

            Bullet newBullet(x, y, dx * bulletSpeed, dy * bulletSpeed);
            newBullet.setSize(10); // 例如，设置子弹大小为10
            bullets.push_back(newBullet);
        }
    }
}

void Enemy::drawBullets() {
    if(type == AIR) {
    al_draw_filled_rectangle(x, y, x + 10, y + 10, al_map_rgb(255, 255, 255));
    }
}


EnemyType Enemy::getType() const {
    return type;
}

void Enemy::removeInactiveBullets() {
    bullets.erase(std::remove_if(bullets.begin(), bullets.end(),
                   [](const Bullet& bullet) { return !bullet.isAlive(); }),
                   bullets.end());
}

void Enemy::clearBullets() {
    bullets.clear();
}


============== 
File: .\gameWindow.cpp 
-------------- 
#include "gameWindow.h"
#include "log.h"  // Include your log class
#include "algorithm"
#include "bullet.h"


#include <iterator>
using namespace std;

GameWindow::GameWindow() : currentState(MENU),previousState(MENU),backgroundImage(nullptr),doexit(false),gameSceneInitialized(false){
    Log::Info("GameWindow Created");
    init();
    //enemies.push_back(Enemy(100, 100, 0.5));
}

GameWindow::~GameWindow() {
    Log::Info("GameWindow Deleted");
    al_destroy_display(display);
    al_destroy_event_queue(event_queue);
    if (ui_font) {
        al_destroy_font(ui_font);
    }
    if (backgroundImage) {
        al_destroy_bitmap(backgroundImage);
    }
}

void GameWindow::init() {
    Log::Info("Init Started:");

    // Initialize Allegro subsystems
    if (!al_init()) {
        Log::Error("Failed to initialize Allegro");
        return;
    }
    if (!al_install_keyboard()) {
        Log::Error("Failed to initialize keyboard");
        return;
    }
    if (!al_init_image_addon()) {
        Log::Error("Failed to initialize image addon");
        return;
    }
    if (!al_init_primitives_addon()) {
        Log::Error("Failed to initialize primitives addon");
        return;
    }
    if (!al_install_mouse()) {
        Log::Error("Failed to initialize mouse");
        return;
    }
    // Initialize font add-ons
    al_init_font_addon(); // Initialize the font addon
    if (!al_init_ttf_addon()) { // Initialize the TrueType font addon
        Log::Error("Failed to initialize TTF font addon");
        return;
    }
// Initialize the font for the menu
    Log::Info("Loading font...");
    font = al_load_font("fonts/ARCADE.TTF", 36, 0);
    if (!font) {
        Log::Error("Failed to load font at fonts/ARCADE.TTF");
    }
    menu.init(font);
    //ui font
    ui_font = al_load_font("fonts/ARCADE.TTF", 24, 0); // Load a font
    if (!ui_font) {
        Log::Error("Failed to load UI font");
    }
    startTime = al_get_time(); // Record the start time
// Initialize audio subsystem
    if (!al_install_audio()) {
        Log::Error("Failed to initialize audio");
        return;
    }
    if (!al_init_acodec_addon()) {
        Log::Error("Failed to initialize audio codec addon");
        return;
    }
    if (!al_reserve_samples(16)) {  // Reserve enough sample instances for your game
        Log::Error("Failed to reserve audio samples");
        return;
    }
    // Load background image
    backgroundImage = al_load_bitmap("img/bg.jpeg");
    if (!backgroundImage) {
        Log::Error("Failed to load background image");
        return;
    }
    // Init background Music
    menuMusic = al_load_sample("audio/Electroman-Adventures.mp3");
    gameMusic = al_load_sample("audio/Electroman-Adventures.mp3");

const char* playerGifFiles[2] = {
        "player_img/skeleton_left.gif",   // Replace with actual file path
        "player_img/skeleton_right.gif",  // Replace with actual file path
    };

// Log the loading of each GIF file
    for (int i = 0; i < 2; ++i) {
        Log::Info(std::string("Loading GIF: ") + playerGifFiles[i]);
    }

if (!menuMusic || !gameMusic) {
    Log::Error("Failed to load music files");
    return;
}

    // Create display
    display = al_create_display(800, 600);
    if (!display) {
        Log::Error("Display failed to be created");
        return;
    } else {
        Log::Info("Display created");
    }
    // Create timer
    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 60.0); // 60 FPS
    if (!timer) {
        Log::Error("Timer failed to be created");
        return;
    } else {
        Log::Info("Timer created");
    }

    // Create event queue
    event_queue = al_create_event_queue();
    if (!event_queue) {
        Log::Error("Event queue failed to be created");
        return;
    } else {
        Log::Info("Event queue created");
    }

    // Register event sources
    al_register_event_source(event_queue, al_get_display_event_source(display));
    al_register_event_source(event_queue, al_get_keyboard_event_source());
    al_register_event_source(event_queue, al_get_timer_event_source(timer));
    al_register_event_source(event_queue, al_get_mouse_event_source());
    al_start_timer(timer);

    player.init(400, 500,playerGifFiles);

    Log::Info("GameWindow initialization complete");
}

void GameWindow::initMenuScene()
{
    Log::Info("Menu Scene Initialized");
}
void GameWindow::initGameOverScene() {
    // Add your game over scene initialization code here
    Log::Info("Game Over Scene Initialized");
    // Example: Load game over assets, set up UI elements, etc.
}
void GameWindow::initGameScene()
{
    if(!gameSceneInitialized)
    {
        if(backgroundImage!=nullptr)
        {
        al_draw_bitmap(backgroundImage, 0, 0, 0);
        Log::Info("Background Init");
        }
        gameSceneInitialized=true;
    }
    al_play_sample(menuMusic, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP, NULL);
}
void GameWindow::initScene() {
    // Check if the current state is different from the previous state
    if (currentState != previousState) {
        switch (currentState) {
            case MENU:
                initMenuScene();  // Initialize menu-specific resources
                break;
            case GAME:
                initGameScene();  // Initialize game-specific resources
                break;
            case GAME_OVER:

                break;
            // Add other cases as needed
        }
        previousState = currentState;  // Update the previous state
    }
}
void GameWindow::run() {
    Log::Info("Game Started!");

    while (!doexit) {
        ALLEGRO_EVENT ev;
        al_wait_for_event(event_queue, &ev);
        initScene();
        switch (currentState) {
            case MENU:
            //Log::Info("In Menu State");
                if (ev.type == ALLEGRO_EVENT_KEY_UP) {
                    if (ev.keyboard.keycode == ALLEGRO_KEY_ENTER) {
                        Log::Info("Enter Key Pressed - Switching to Game State"); // Debug message for pressing Enter
                        al_stop_samples(); // Stop any currently playing music
                        currentState = GAME;
                        menu.gameStart = true; // Update the flag in menu
                    }
                }
                menu.update();
                break;

            case GAME:
            //Log::Info("In Menu State");
            static double last_spawn_time = 0;
            static double enemySpawnInterval = 2.0;
            // Check if the player's health is 0 or less
            if (player.getHp() <= 0) {
                //Log::Info("Game Over!");
                currentState = GAME_OVER;
            }
            

            switch (ev.type) {
            case ALLEGRO_EVENT_TIMER:
            
                player.update();
                // 遍历所有敌人
                for (auto& enemy : enemies) {
                    enemy.update(); // 更新敌人位置和状态
                    enemy.removeInactiveBullets();
                    // 如果敌人是天空中的敌人，则射击玩家
                    if (enemy.getType() == EnemyType::AIR) {
                        enemy.shootAtPlayer(player); // 让敌人射击玩家
                    }
                }

                // 将死亡或离开屏幕的敌人的子弹转移到全局子弹列表
                /*for (auto& enemy : enemies) {
                    if (!enemy.isAlive() || enemy.isOffScreen()) {
                        const auto& enemyBullets = enemy.getBullets();
                        bullets.insert(bullets.end(), enemyBullets.begin(), enemyBullets.end());
                        enemy.clearBullets(); // 清空敵人的子彈列表
                    }
                }*/

                // 移除不再存活或已经离开屏幕的敌人
                enemies.erase(std::remove_if(enemies.begin(), enemies.end(),
                    [](const Enemy& enemy) {
                        return !enemy.isAlive() || enemy.isOffScreen();
                    }), enemies.end());

                 // 更新全局子弹列表
                for (auto& bullet : bullets) {
                    bullet.update();
                }
                // 移除不活跃的子弹
                /*bullets.erase(std::remove_if(bullets.begin(), bullets.end(), 
                    [](const Bullet& b) { return !b.isAlive(); }), bullets.end());*/
                
                if (al_get_time() - last_spawn_time > enemySpawnInterval) {
                    last_spawn_time = al_get_time();
                    float spawnY;
                    float velocityX;
                    EnemyType type;

                    // 随机决定生成哪种类型的敌人
                    if (rand() % 2 == 0) {
                        // 生成天上的敌人
                        spawnY = static_cast<float>(rand() % 300); // 屏幕上半部
                        velocityX = 1.0; // 初始速度
                        type = EnemyType::AIR;
                    } else {
                        // 生成地上的敌人
                        spawnY = 500; // 与玩家相同的高度
                        velocityX = 2.0; // 天上敌人速度的两倍
                        type = EnemyType::GROUND;
                    }

                    // 随机决定敌人从左侧或右侧出现
                    float spawnX;
                    if (rand() % 2 == 0) {
                        spawnX = -1; // 从屏幕左侧出现
                    } else {
                        spawnX = 801; // 从屏幕右侧出现
                        velocityX = -velocityX; // 改变移动方向
                    }

                    // 添加敌人到列表
                    enemies.push_back(Enemy(spawnX, spawnY, velocityX, type));
                    enemySpawnInterval = std::max(1.0, enemySpawnInterval - 0.1); // 逐渐减少间隔时间
                }



                
                // Add any other updates here, e.g., for game world, enemies, etc.
                break;

            case ALLEGRO_EVENT_DISPLAY_CLOSE:
                doexit = true;
                break;

            case ALLEGRO_EVENT_KEY_DOWN:
                key_state[ev.keyboard.keycode] = true;
                break;

            case ALLEGRO_EVENT_KEY_UP:
                key_state[ev.keyboard.keycode] = false;
                if (ev.keyboard.keycode == ALLEGRO_KEY_ESCAPE) {
                    Log::Info("Escape Key Pressed - Switching to Menu State"); // Debug message for pressing Escape
                    al_stop_samples(); // Stop any currently playing music
                    currentState = MENU;
                }
                break;

            case ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
                if (ev.mouse.button & 1) { // Left mouse button
                    Log::Info("Left Mouse Button Clicked");
                    player.shoot(ev.mouse.x, ev.mouse.y);
                }
                if (ev.mouse.button & 2) {  // Right mouse button
        Log::Info("Right Mouse Button Clicked");

    }
                break;
                case GAME_OVER:

                
                break;

            // Add additional cases here for other types of events
        }

        

        // 检测子弹与敌人的碰撞
        for (auto& bullet : player.getBullets()) {
            if (bullet.isHit()) continue; // 如果子弹已经击中了敌人，跳过这个子弹

            for (auto& enemy : enemies) {
                if (checkCollision(bullet, enemy) && enemy.isAlive()) {
                    enemy.hit(bullet.getDamage());
                    bullet.setHit(true); // 标记子弹已经击中敌人
                    bullet.setAlive(false); // 设置子弹为不活跃
                    if(enemy.hp<=0){score++;}
                    break; // 退出内部循环
                }
            }
        }

        /*for (auto& enemy : enemies) {
            for (auto& bullet : enemy.getBullets()) {
                bullet.update();
                if (!bullet.isAlive()) {
                    // 如果子弹不再活跃，将其从敌人的子弹列表中移除
                    enemy.removeInactiveBullets();
                } else {
                    // 否则绘制子弹
                    bullet.draw();
                }
            }
        }*/

        // 移除已不活动的敌人
        enemies.erase(std::remove_if(enemies.begin(), enemies.end(), 
                   [](const Enemy& enemy) { return !enemy.isAlive() || enemy.isOffScreen(); }), enemies.end());
        case GAME_OVER:

        break;

        }

        
        draw();
    }
}


void GameWindow::draw() {
    al_clear_to_color(al_map_rgb(0, 0, 0));

    // Move the declarations outside the switch statement
    std::ostringstream timeStream;
    std::string timeText;
    std::string scoreText;
    const int maxHealthWidth = 750; // Maximum width of the health bar
    int currentHealthWidth;

    switch (currentState) {
        case MENU:
            menu.draw();
            break;

        case GAME:
            currentTime = static_cast<int>(al_get_time() - startTime);
            timeStream << "Time: " << currentTime;
            timeText = timeStream.str();
            scoreText = "Score: " + std::to_string(score);

            // Draw Health Bar
            currentHealthWidth = static_cast<int>((player.getHp() / 100) * maxHealthWidth);
            al_draw_filled_rectangle(10, 600 - 30, 10 + currentHealthWidth, 600 - 10, al_map_rgb(255, 0, 0));

            // Draw text
            al_draw_text(ui_font, al_map_rgb(255, 255, 255), 10, 10, 0, timeText.c_str());
            al_draw_text(ui_font, al_map_rgb(255, 255, 255), 10, 40, 0, scoreText.c_str());
            
            al_play_sample(gameMusic, 1.0, 0.0, 1.0, ALLEGRO_PLAYMODE_LOOP, NULL);
            player.draw();
            for (auto& enemy : enemies) {

                enemy.draw();
            }
            for (auto& bullet : bullets) {
                bullet.draw();
            }
            break;

        case GAME_OVER:
            // Drawing code for game over screen
            al_draw_text(ui_font, al_map_rgb(255, 0, 0), 400, 300, ALLEGRO_ALIGN_CENTER, "Game Over");
            break;
    }

    al_flip_display();
}
bool GameWindow::checkCollision(const Bullet &bullet, const Enemy &enemy) {
    // Simple circle-rectangle collision detection
    float distX = std::abs(bullet.x - enemy.x);
    float distY = std::abs(bullet.y - enemy.y);

    if (distX > (bullet.getSize()/ 2 + Enemy::RADIUS)) { return false; }
    if (distY > (bullet.getSize()/ 2 + Enemy::RADIUS)) { return false; }

    if (distX <= (bullet.getSize()/ 2)) { return true; } 
    if (distY <= (bullet.getSize()/ 2)) { return true; }

    // Corner collision
    float dx = distX - bullet.getSize()/ 2;
    float dy = distY - bullet.getSize()/ 2;
    return (dx * dx + dy * dy <= (Enemy::RADIUS * Enemy::RADIUS));
}

============== 
File: .\gif.cpp 
-------------- 
#include "algif.h"

#include <stdlib.h>
#include <string.h>

int LZW_decode (ALLEGRO_FILE * file, ALGIF_BITMAP *bmp);

/* Destroy a complete gif, including all frames. */
void algif_destroy_animation(ALGIF_ANIMATION *gif) {
    int i;

    for (i = 0; i < gif->frames_count; i++)
    {
        ALGIF_FRAME *frame = gif->frames + i;

        if (frame->bitmap_8_bit)
            algif_destroy_bitmap (frame->bitmap_8_bit);
        if (frame->rendered)
            al_destroy_bitmap(frame->rendered);
    }
    if (gif->store)
        al_destroy_bitmap(gif->store);
    free (gif->frames);
    free (gif);
}

static void read_palette (ALLEGRO_FILE * file, ALGIF_PALETTE *palette) {
    int i;

    for (i = 0; i < palette->colors_count; i++)
    {
        palette->colors[i].r = al_fgetc (file);
        palette->colors[i].g = al_fgetc (file);
        palette->colors[i].b = al_fgetc (file);
    }
}

static void deinterlace (ALGIF_BITMAP *bmp)
{
    ALGIF_BITMAP *n = algif_create_bitmap (bmp->w, bmp->h);
    int y, i = 0;
    for (y = 0; y < n->h; y += 8)
    {
        algif_blit (bmp, n, 0, i++, 0, y, n->w, 1);
    }
    for (y = 4; y < n->h; y += 8)
    {
        algif_blit (bmp, n, 0, i++, 0, y, n->w, 1);
    }
    for (y = 2; y < n->h; y += 4)
    {
        algif_blit (bmp, n, 0, i++, 0, y, n->w, 1);
    }
    for (y = 1; y < n->h; y += 2)
    {
        algif_blit (bmp, n, 0, i++, 0, y, n->w, 1);
    }
    algif_blit (n, bmp, 0, 0, 0, 0, n->w, n->h);
    algif_destroy_bitmap (n);
}

ALGIF_ANIMATION *algif_load_raw(ALLEGRO_FILE *file) {
    if (!file)
        return NULL;

    int version;
    ALGIF_BITMAP *bmp = NULL;
    int i, j;
    ALGIF_ANIMATION *gif = (ALGIF_ANIMATION *)calloc (1, sizeof *gif);
    ALGIF_FRAME frame;
    gif->frames_count = 0;

    /* is it really a GIF? */
    if (al_fgetc (file) != 'G')
        goto error;
    if (al_fgetc (file) != 'I')
        goto error;
    if (al_fgetc (file) != 'F')
        goto error;
    if (al_fgetc (file) != '8')
        goto error;
    /* '7' or '9', for 87a or 89a. */
    version = al_fgetc (file);
    if (version != '7' && version != '9')
        goto error;
    if (al_fgetc (file) != 'a')
        goto error;

    gif->width = al_fread16le (file);
    gif->height = al_fread16le (file);
    i = al_fgetc (file);
    /* Global color table? */
    if (i & 128)
        gif->palette.colors_count = 1 << ((i & 7) + 1);
    else
        gif->palette.colors_count = 0;
    /* Background color is only valid with a global palette. */
    gif->background_index = al_fgetc (file);

    /* Skip aspect ratio. */
    al_fseek (file, 1, ALLEGRO_SEEK_CUR);

    if (gif->palette.colors_count)
    {
        read_palette (file, &gif->palette);
    }

    memset(&frame, 0, sizeof frame); /* For first frame. */
    frame.transparent_index = -1;

    do
    {
        i = al_fgetc (file);

        switch (i)
        {
            case 0x2c:         /* Image Descriptor */
            {
                int w, h;
                int interlaced = 0;

                frame.xoff = al_fread16le (file);
                frame.yoff = al_fread16le (file);
                w = al_fread16le (file);
                h = al_fread16le (file);
                bmp = algif_create_bitmap (w, h);
                if (!bmp)
                    goto error;
                i = al_fgetc (file);

                /* Local palette. */
                if (i & 128)
                {
                    frame.palette.colors_count = 1 << ((i & 7) + 1);
                    read_palette (file, &frame.palette);
                }
                else
                {
                    frame.palette.colors_count = 0;
                }

                if (i & 64)
                    interlaced = 1;

                if (LZW_decode (file, bmp))
                    goto error;

                if (interlaced)
                    deinterlace (bmp);

                frame.bitmap_8_bit = bmp;
                bmp = NULL;

                gif->frames_count++;
                gif->frames =
                    (ALGIF_FRAME*)realloc (gif->frames,
                             gif->frames_count * sizeof *gif->frames);
                gif->frames[gif->frames_count - 1] = frame;

                memset(&frame, 0, sizeof frame); /* For next frame. */
                frame.transparent_index = -1;

                break;
            }
            case 0x21: /* Extension Introducer. */
                j = al_fgetc (file); /* Extension Type. */
                i = al_fgetc (file); /* Size. */
                if (j == 0xf9) /* Graphic Control Extension. */
                {
                    /* size must be 4 */
                    if (i != 4)
                        goto error;
                    i = al_fgetc (file);
                    frame.disposal_method = (i >> 2) & 7;
                    frame.duration = al_fread16le (file);
                    if (i & 1)  /* Transparency? */
                    {
                        frame.transparent_index = al_fgetc (file);
                    }
                    else
                    {
                        al_fseek (file, 1, ALLEGRO_SEEK_CUR);
                        frame.transparent_index = -1;
                    }
                    i = al_fgetc (file); /* Size. */
                }
                /* Application Extension. */
                else if (j == 0xff)
                {
                    if (i == 11)
                    {
                        char name[12];
                        al_fread (file, name, 11);
                        i = al_fgetc (file); /* Size. */
                        name[11] = '\0';
                        if (!strcmp (name, "NETSCAPE2.0"))
                        {
                            if (i == 3)
                            {
                                j = al_fgetc (file);
                                gif->loop = al_fread16le (file);
                                if (j != 1)
                                    gif->loop = 0;
                                i = al_fgetc (file); /* Size. */
                            }
                        }
                    }
                }

                /* Possibly more blocks until terminator block (0). */
                while (i)
                {
                    al_fseek (file, i, ALLEGRO_SEEK_CUR);
                    i = al_fgetc (file);
                }
                break;
            case 0x3b:
                /* GIF Trailer. */
                al_fclose (file);
                return gif;
        }
    }
    while (true);
  error:
    if (file)
        al_fclose (file);
    if (gif)
        algif_destroy_animation (gif);
    if (bmp)
        algif_destroy_bitmap (bmp);
    return NULL;
}
============== 
File: .\global.cpp 
-------------- 
#include "global.h"

bool key_state[ALLEGRO_KEY_MAX] = { false };
============== 
File: .\level.cpp 
-------------- 
#include "level.h"

Level::Level() {
    // Constructor implementation
}

void Level::loadLevel(const char* filename) {
    // Load level data from file
}

void Level::update() {
    // Update level objects
}

void Level::render() {
    // Render level
}
============== 
File: .\log.cpp 
-------------- 
#include "log.h"

void Log::Info(const std::string& message) {
    std::cout << "INFO: " << message << std::endl;
}

void Log::Error(const std::string& message) {
    std::cerr << "ERROR: " << message << std::endl;
}
============== 
File: .\lzw.cpp 
-------------- 
#include "algif.h"

static int
read_code (ALLEGRO_FILE * file, char *buf, int *bit_pos, int bit_size)
{
    int i;
    int code = 0;
    int pos = 1;

    for (i = 0; i < bit_size; i++)
    {
        int byte_pos = (*bit_pos >> 3) & 255;

        if (byte_pos == 0)
        {
            int data_len = al_fgetc (file);

            if (data_len == 0)
            {
                //printf ("Fatal. Errorneous GIF stream.\n");
                //abort ();
                return -1;
            }
            al_fread (file, buf + 256 - data_len, data_len);
            byte_pos = 256 - data_len;
            *bit_pos = byte_pos << 3;
        }
        if (buf[byte_pos] & (1 << (*bit_pos & 7)))
            code += pos;
        pos += pos;
        (*bit_pos)++;
    }
    return code;
}

int
LZW_decode (ALLEGRO_FILE * file, ALGIF_BITMAP *bmp)
{
    int orig_bit_size;
    char buf[256];
    int bit_size;
    int bit_pos;
    int clear_marker;
    int end_marker;
    struct
    {
        int prefix;
        int c;
        int len;
    }
    codes[4096];                /* Maximum bit size is 12. */
    int n;
    int i, prev, code, c;
    int out_pos = 0;

    orig_bit_size = al_fgetc (file);
    n = 2 + (1 << orig_bit_size);

    for (i = 0; i < n; i++)
    {
        codes[i].c = i;
        codes[i].len = 0;
    }

    clear_marker = n - 2;
    end_marker = n - 1;

    bit_size = orig_bit_size + 1;

    bit_pos = 0;

    /* Expect to read clear code as first code here. */
    prev = read_code (file, buf, &bit_pos, bit_size);
    //printf("%d %d = %d\n", bit_pos, bit_size, prev);
    if (prev == -1)
        return -1;
    do
    {
        code = read_code (file, buf, &bit_pos, bit_size);
        //printf("%d %d = %d\n", bit_pos, bit_size, code);
        if (code == -1)
            return -1;
        if (code == clear_marker)
        {
            bit_size = orig_bit_size;
            n = 1 << bit_size;
            n += 2;
            bit_size++;
            prev = code;
            continue;
        }

        if (code == end_marker)
            break;

        /* Known code: ok. Else: must be doubled char. */
        if (code < n)
            c = code;
        else
            c = prev;

        /* Output the code. */
        out_pos += codes[c].len;
        i = 0;
        do
        {
            bmp->data[out_pos - i] = codes[c].c;
            if (codes[c].len)
                c = codes[c].prefix;
            else
                break;
            i++;
        }
        while (1);

        out_pos++;

        /* Unknown code -> must be double char. */
        if (code >= n)
        {
            bmp->data[out_pos] = codes[c].c;
            out_pos++;
        }

        /* Except after clear marker, build new code. */
        if (prev != clear_marker)
        {
            codes[n].prefix = prev;
            codes[n].len = codes[prev].len + 1;
            codes[n].c = codes[c].c;
            n++;
        }

        /* Out of bits? Increase. */
        if (n == (1 << bit_size))
        {
            if (bit_size < 12)
                bit_size++;
        }

        prev = code;
    }
    while (1);
    return 0;
}
============== 
File: .\main.cpp 
-------------- 
#include "gameWindow.h"
#include "allegro_setup.h"
#include <iostream>
using namespace std;

int main() {
    GameWindow window;
    window.run();

    return 0;
}
============== 
File: .\menu.cpp 
-------------- 
// menu.cpp
#include "menu.h"
#include "log.h"
Menu::Menu() : gameStart(false), font(nullptr) {}

Menu::~Menu() {
    // Font is managed by GameWindow, so no need to destroy it here
}

void Menu::init(ALLEGRO_FONT* font) {
    this->font = font;
}

void Menu::update() {
    // Update logic for the menu (e.g., button highlights)
}

void Menu::draw() {
    if (!font) {
        //Log::Error("Font not loaded");
        return;
    }
    
    al_draw_text(font, al_map_rgb(255, 255, 255), 400, 300, ALLEGRO_ALIGN_CENTER, "Press Enter to Start");
}

bool Menu::startGame() const {
    return gameStart;
}

// Implement any additional methods you need for the menu============== 
File: .\player.cpp 
-------------- 
#include "player.h"
#include "global.h"
#include "bullet.h"
#include "log.h"
#include <vector>
#include <cmath>
#include <algorithm>

const float GRAVITY = 0.5;
const float JUMP_STRENGTH = -10.0;
const int PLAYER_SIZE = 32;
const int INITIAL_HP = 100; // Initial health points

Player::Player() {
    for (int i = 0; i < 4; ++i) {
        walkingGif[i] = nullptr;
    }
}

Player::~Player() {
    for (int i = 0; i < 2; ++i) {
        if (walkingGif[i] != nullptr) {
            algif_destroy_animation(walkingGif[i]);
        }
    }
}
void Player::init(float startX, float startY,const char* gifFile[2]) {
    x = startX;
    y = startY;
    dy = 0;
    onGround = true;
    facingRight = true;
    bulletSpeed = 15.0f;
    dashing = false;
    lastDashTime = 0.0;
    currentWeapon = PISTOL;
    hp = INITIAL_HP;

    for(int i = 0; i < 2; i++) {
        walkingGif[i] = algif_load_animation(gifFile[i]);
        if (!walkingGif[i]) {
            Log::Error("Failed to load GIF: " + std::string(gifFile[i]));
        }
    }
    
}

float Player::getX() const{
    return x;
}

float Player::getY() const{
    return y;
}




void Player::update() {

    if (key_state[ALLEGRO_KEY_1]) {
        currentWeapon = PISTOL;
        Log::Info("Weapon change to pistol");
    }
    if (key_state[ALLEGRO_KEY_2]) {
        currentWeapon = SHOTGUN;
        Log::Info("Weapon change to shotgun");
    }
    if (key_state[ALLEGRO_KEY_3]) {
        currentWeapon = BAZOOKA;
        Log::Info("Weapon change to bazooka");
    }

    if (!onGround) {
        dy += GRAVITY;
        y += dy;
    }

    if (y >= 600 - 100 - PLAYER_SIZE) {
        y = 600 - 100 - PLAYER_SIZE;
        dy = 0;
        onGround = true;
    }

    if (key_state[ALLEGRO_KEY_A]) {
        x -= 4.0;
        facingRight = false;
        currentDirection = 0; // Assuming left direction
    }
    if (key_state[ALLEGRO_KEY_D]) {
        x += 4.0;
        facingRight = true;
        currentDirection = 1; // Assuming left direction
    }

    if (key_state[ALLEGRO_KEY_SPACE] && onGround) {
        dy = JUMP_STRENGTH;
        onGround = false;
    }

    if (key_state[ALLEGRO_KEY_F] && !dashing) {
        // Implement dash behavior here
        if(facingRight)
        {
        x += 20.0;
        }
        else if(!facingRight)
        {
        x-=20.0;
        }
        dashing = false;
        lastDashTime = al_get_time(); // Record the time of the dash
    }

        // Check if the cooldown is over and reset the dash flag
    if (al_get_time() - lastDashTime >= DASH_COOLDOWN) {
        dashing = false;
    }

    // Update bullets
    for (auto& bullet : bullets) {
        bullet.update();
    }


}

void Player::draw() {
     //al_draw_filled_rectangle(x, y, x + PLAYER_SIZE, y + PLAYER_SIZE, al_map_rgb(255, 0, 0));

     ALLEGRO_BITMAP* frameBitmap = algif_get_bitmap(walkingGif[currentDirection], al_get_time());
     if (frameBitmap) {
        // Get the dimensions of the bitmap
        int bitmapWidth = al_get_bitmap_width(frameBitmap);
        int bitmapHeight = al_get_bitmap_height(frameBitmap);

        // Calculate the position to draw the bitmap so that it's centered on the player's coordinates
        float drawX = x - bitmapWidth / 2.0f;
        float drawY = y - bitmapHeight / 2.0f;

        // Draw the bitmap
        al_draw_bitmap(frameBitmap, drawX, drawY, 0);
    }
        // Draw each bullet
    for (auto& bullet : bullets) {
        bullet.draw();
    }
}

void Player::shoot(float target_x, float target_y) {
    float dx = target_x - x;
    float dy = target_y - y;
    float length = std::sqrt(dx * dx + dy * dy);
    dx /= length; // Normalize
    dy /= length;

    dx *= bulletSpeed;
    dy *= bulletSpeed;

    switch (currentWeapon) {
        case PISTOL: {
            Bullet newBullet(x, y, dx, dy);
            newBullet.setDamage(2);
            newBullet.setSize(10);
            bullets.push_back(newBullet);
            break;
        }
        case SHOTGUN: {
            for (int i = 0; i < 3; ++i) {
                float angle = i * 0.1f - 0.1f; // Adjust angle for each bullet
                float newDx = dx * std::cos(angle) - dy * std::sin(angle);
                float newDy = dy * std::cos(angle) + dx * std::sin(angle);
                Bullet newBullet(x, y, newDx, newDy);
                newBullet.setSize(20);
                newBullet.setDamage(1);
                bullets.push_back(newBullet);
            }
            break;
        }
        case BAZOOKA: {
            Bullet bazookaBullet(x, y, dx, dy);
            bazookaBullet.setSize(50); // Adjusted size for the bazooka bullet
            bazookaBullet.setDamage(100);
            bullets.push_back(bazookaBullet);
            break;
        }
    }
}

void Player::markBulletDead(int index) {
    // 将 index 转换为无符号类型
    auto unsignedIndex = static_cast<std::vector<Bullet>::size_type>(index);

    if (index >= 0 && unsignedIndex < bullets.size()) {
        // 使用公共方法来设置子弹的状态
        bullets[unsignedIndex].setAlive(false);
    }
}

void Player::hit(int damage) {
    hp -= damage;
    if (hp < 0) {
        hp = 0;
    }
    // Additional logic when player's health reaches 0
}
============== 
